import { Event, StateValue, ActionType, Action, EventObject, StateInterface, PropertyMapper, Mapper, EventType, HistoryValue, OmniEventObject, AssignAction, ActionObject, Condition, Guard, Subscribable, StateMachine, ConditionPredicate } from './types';
export declare function keys<T extends object>(value: T): Array<keyof T & string>;
export declare function matchesState(parentStateId: StateValue, childStateId: StateValue, delimiter?: string): boolean;
export declare function getEventType<TEvent extends EventObject = EventObject>(event: Event<TEvent>): TEvent['type'];
export declare function getActionType(action: Action<any, any>): ActionType;
export declare function toStatePath(stateId: string | string[], delimiter: string): string[];
export declare function toStateValue(stateValue: StateInterface<any> | StateValue | string[], delimiter: string): StateValue;
export declare function pathToStateValue(statePath: string[]): StateValue;
export declare function mapValues<T, P>(collection: {
    [key: string]: T;
}, iteratee: (item: T, key: string, collection: {
    [key: string]: T;
}, i: number) => P): {
    [key: string]: P;
};
export declare function mapFilterValues<T, P>(collection: {
    [key: string]: T;
}, iteratee: (item: T, key: string, collection: {
    [key: string]: T;
}) => P, predicate: (item: T) => boolean): {
    [key: string]: P;
};
/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */
export declare const path: <T extends Record<string, any>>(props: string[]) => any;
/**
 * Retrieves a value at the given path via the nested accessor prop.
 * @param props The deep path to the prop of the desired value
 */
export declare function nestedPath<T extends Record<string, any>>(props: string[], accessorProp: keyof T): (object: T) => T;
export declare function toStatePaths(stateValue: StateValue | undefined): string[][];
export declare const pathsToStateValue: (paths: string[][]) => StateValue;
export declare function flatten<T>(array: Array<T | T[]>): T[];
export declare function toArray<T>(value: T[] | T | undefined): T[];
export declare function mapContext<TContext, TEvent extends EventObject>(mapper: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>, context: TContext, event: TEvent): any;
export declare function isBuiltInEvent(eventType: EventType): boolean;
export declare function isPromiseLike(value: any): value is PromiseLike<any>;
export declare function partition<T, A extends T, B extends T>(items: T[], predicate: (item: T) => item is A): [A[], B[]];
export declare function updateHistoryStates(hist: HistoryValue, stateValue: StateValue): Record<string, HistoryValue | undefined>;
export declare function updateHistoryValue(hist: HistoryValue, stateValue: StateValue): HistoryValue;
export declare function updateContext<TContext, TEvent extends EventObject>(context: TContext, event: OmniEventObject<TEvent>, assignActions: Array<AssignAction<TContext, TEvent>>): TContext;
export declare function bindActionToState<TC, TE extends EventObject>(action: ActionObject<TC, TE>, state: StateInterface<TC, TE>): ActionObject<TC, TE>;
declare let warn: (condition: boolean | Error, message: string) => void;
export { warn };
export declare function isArray(value: any): value is any[];
export declare function isFunction(value: any): value is Function;
export declare function isString(value: any): value is string;
export declare function toGuard<TContext, TEvent extends EventObject>(condition?: Condition<TContext, TEvent>, guardMap?: Record<string, ConditionPredicate<TContext, TEvent>>): Guard<TContext, TEvent> | undefined;
export declare function isObservable<T>(value: Subscribable<T> | any): value is Subscribable<T>;
export declare function isMachine(value: any): value is StateMachine<any, any, any>;
export declare const uniqueId: () => string;
