import { StateMachine, Event, EventObject, DefaultContext, StateSchema, OmniEventObject, OmniEvent, InvokeCallback, StateValue, InterpreterOptions, SingleOrArray, Subscribable, DoneEvent, Unsubscribable, MachineOptions } from './types';
import { State } from './State';
import { Actor } from './Actor';
export declare type StateListener<TContext, TEvent extends EventObject> = (state: State<TContext, TEvent>, event: OmniEventObject<TEvent>) => void;
export declare type ContextListener<TContext = DefaultContext> = (context: TContext, prevContext: TContext | undefined) => void;
export declare type EventListener<TEvent extends EventObject = EventObject> = (event: TEvent) => void;
export declare type Listener = () => void;
export interface Clock {
    setTimeout(fn: (...args: any[]) => void, timeout: number): any;
    clearTimeout(id: any): void;
}
interface SpawnOptions {
    name?: string;
    autoForward?: boolean;
    sync?: boolean;
}
export declare class Interpreter<TContext, TStateSchema extends StateSchema = any, TEvent extends EventObject = EventObject> implements Subscribable<State<TContext, TEvent>>, Actor<State<TContext, TEvent>, OmniEventObject<TEvent>> {
    machine: StateMachine<TContext, TStateSchema, TEvent>;
    /**
     * The default interpreter options:
     *
     * - `clock` uses the global `setTimeout` and `clearTimeout` functions
     * - `logger` uses the global `console.log()` method
     */
    static defaultOptions: InterpreterOptions;
    /**
     * The current state of the interpreted machine.
     */
    state: State<TContext, TEvent>;
    /**
     * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.
     */
    clock: Clock;
    options: Readonly<InterpreterOptions>;
    private scheduler;
    private delayedEventsMap;
    private listeners;
    private contextListeners;
    private stopListeners;
    private doneListeners;
    private eventListeners;
    private sendListeners;
    private logger;
    /**
     * Whether the service is started.
     */
    initialized: boolean;
    /**
     * The initial state of the machine.
     */
    initialState: State<TContext, TEvent>;
    parent?: Interpreter<any>;
    id: string;
    children: Map<string | number, Actor>;
    private forwardTo;
    private devTools?;
    /**
     * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
     *
     * @param machine The machine to be interpreted
     * @param options Interpreter options
     */
    constructor(machine: StateMachine<TContext, TStateSchema, TEvent>, options?: Partial<InterpreterOptions>);
    static interpret: typeof interpret;
    /**
     * Executes the actions of the given state, with that state's `context` and `event`.
     *
     * @param state The state whose actions will be executed
     * @param actionsConfig The action implementations to use
     */
    execute(state: State<TContext, TEvent>, actionsConfig?: MachineOptions<TContext, TEvent>['actions']): void;
    private update;
    onTransition(listener: StateListener<TContext, TEvent>): Interpreter<TContext, TStateSchema, TEvent>;
    subscribe(nextListener?: (state: State<TContext, TEvent>) => void, errorListener?: (error: any) => void, completeListener?: () => void): Unsubscribable;
    /**
     * Adds an event listener that is notified whenever an event is sent to the running interpreter.
     * @param listener The event listener
     */
    onEvent(listener: EventListener): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Adds an event listener that is notified whenever a `send` event occurs.
     * @param listener The event listener
     */
    onSend(listener: EventListener): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Adds a context listener that is notified whenever the state context changes.
     * @param listener The context listener
     */
    onChange(listener: ContextListener<TContext>): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Adds a listener that is notified when the machine is stopped.
     * @param listener The listener
     */
    onStop(listener: Listener): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Adds a state listener that is notified when the statechart has reached its final state.
     * @param listener The state listener
     */
    onDone(listener: EventListener<DoneEvent>): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Removes a listener.
     * @param listener The listener to remove
     */
    off(listener: (...args: any[]) => void): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Alias for Interpreter.prototype.start
     */
    init: (initialState?: string | import("./types").StateValueMap | State<TContext, TEvent> | undefined) => Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Starts the interpreter from the given state, or the initial state.
     * @param initialState The state to start the statechart from
     */
    start(initialState?: State<TContext, TEvent> | StateValue): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Stops the interpreter and unsubscribe all listeners.
     *
     * This will also notify the `onStop` listeners.
     */
    stop(): Interpreter<TContext, TStateSchema, TEvent>;
    /**
     * Sends an event to the running interpreter to trigger a transition.
     *
     * An array of events (batched) can be sent as well, which will send all
     * batched events to the running interpreter. The listeners will be
     * notified only **once** when all events are processed.
     *
     * @param event The event(s) to send
     */
    send: (event: SingleOrArray<OmniEvent<TEvent>>, payload?: (Record<string, any> & {
        type?: undefined;
    }) | undefined) => State<TContext, TEvent>;
    private batch;
    /**
     * Returns a send function bound to this interpreter instance.
     *
     * @param event The event to be sent by the sender.
     */
    sender(event: Event<TEvent>): () => State<TContext, TEvent>;
    sendTo: (event: OmniEventObject<TEvent>, to: string | number | Actor<any, EventObject>) => void;
    /**
     * Returns the next state given the interpreter's current state and the event.
     *
     * This is a pure method that does _not_ update the interpreter's state.
     *
     * @param event The event to determine the next state
     */
    nextState(event: OmniEvent<TEvent>): State<TContext, TEvent>;
    private forward;
    private defer;
    private cancel;
    private exec;
    private stopChild;
    spawn<TChildContext>(entity: Spawnable<TChildContext>, name: string, options?: SpawnOptions): Actor;
    spawnMachine<TChildContext, TChildStateSchema, TChildEvents extends EventObject>(machine: StateMachine<TChildContext, TChildStateSchema, TChildEvents>, options?: {
        id?: string;
        autoForward?: boolean;
        sync?: boolean;
    }): Actor<State<TChildContext, TChildEvents>>;
    private spawnPromise;
    private spawnCallback;
    private spawnObservable;
    private spawnActivity;
    private spawnEffect;
    private reportUnhandledExceptionOnInvocation;
    private attachDev;
    toJSON(): {
        id: string;
    };
}
export declare type Spawnable<TContext> = StateMachine<TContext, any, any> | Promise<TContext> | InvokeCallback | Subscribable<TContext>;
export declare function spawn<TContext>(entity: Spawnable<TContext>, nameOrOptions?: string | SpawnOptions): Actor<TContext>;
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */
export declare function interpret<TContext = DefaultContext, TStateSchema extends StateSchema = any, TEvent extends EventObject = EventObject>(machine: StateMachine<TContext, TStateSchema, TEvent>, options?: Partial<InterpreterOptions>): Interpreter<TContext, TStateSchema, TEvent>;
export {};
